# -*- coding: utf-8 -*-
"""Copie_de_Image_to_Text.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E6vT3MO-ZNVEbbRc4TybAW3jpVrPZ2KC

Initialisation/ Installation
"""

#installing doctr
#!pip install python-doctr[torch]
# Restart runtime
#exit()

# !sudo apt install libcairo2-dev pkg-config
# !pip3 install pycairo
# exit()

# pip install tf2onnx

import os
os.environ['USE_TORCH'] = '1'
import matplotlib.pyplot as plt

from doctr.io import DocumentFile
from doctr.models import ocr_predictor
import time

class Extraction :
    '''
        Cette classe a comme but principal d'extraire les lignes à partir d'une image. En effet,
        il nous permet de telcharger un fichier contenant les lignes extraites
    '''
    def __init__(self, image) :
        self.image=DocumentFile.from_pdf(image)
        #self.image=DocumentFile.from_images(image)      #si c'est Image
    def predict(self) : #Pour faire la prédiction
        model = ocr_predictor(det_arch='db_resnet50', reco_arch='crnn_vgg16_bn', pretrained=True,)
        result = model(self.image)
        return result
    def confiance(self):
      dict={}
      result = self.predict()
      output = result.export()
      somme=0
      k=0
      for page in output['pages']:
        for block in page["blocks"]:
          for line in block["lines"]:
            for word in line["words"]:
              somme+=word["confidence"]
              k+=1
              dict[word["value"]]=word["confidence"]
      return (somme/k,dict)


    def show_bounding_boxes(self) :#pour voir une image avec les textes encadrés en utilisant le model
        result=self.predict()
        return result.show(self.image)


    def lignes(self,L): #fonction pour nous aider à extraire les lignes
        lignes=[]
        n=len(L)
        L.sort(key=lambda a:a[1])
        L.sort(key=lambda a:a[0])
        T=[]
        P=[]
        for i in range(n-1):
            if (L[i][0]<=L[i+1][0]+0.04 and L[i][0]>=L[i+1][0]-0.04)   :

                T.append(L[i][1:3])
            else :
                T.append(L[i][1:3])
                T.sort(key=lambda a:a[0])
                P+=[T[i] for i in range(len(T))]
                P.append('STOP')
                T=[]

        s=''
        for i in range(len(P)):
            if P[i]!='STOP' :
                s+=' '+P[i][1]
            else :
                lignes.append(s)
                s=''
        return lignes
    def extract_rows(self):
        result = self.predict()
        output = result.export()
        lignes = []
        for page in output['pages']:
            L = []
            for obj1 in page["blocks"]:
                for obj2 in obj1["lines"]:
                    for obj3 in obj2["words"]:
                        x = (obj3["geometry"][0][0] + obj3["geometry"][1][0]) / 2 * 10
                        y = (obj3["geometry"][0][1] + obj3["geometry"][1][1]) / 2 * 10
                        L.append((y, x, obj3["value"], round(obj3["confidence"], 3)))
            lignes_page = self.lignes(L)
            lignes.append(lignes_page)
        return lignes

    def export_lignes(self, nom_fichier):
        text_file = open(nom_fichier, "w",encoding="UTF-8")
        lignes = self.extract_rows()
        for i, lignes_page in enumerate(lignes):
            text_file.write(f"Page {i+1}:\n")
            for ligne in lignes_page:
                text_file.write(f"{ligne}  \n")
        text_file.close()


    def detecter_corps_texte(self):
        lignes = self.extract_rows()

        # Concaténer toutes les lignes en un seul texte
        texte_complet = ' '.join(' '.join(page) for page in lignes)

        # Vous pouvez maintenant traiter le texte complet selon vos besoins
        # Par exemple, vous pourriez appliquer des techniques de traitement de texte
        # pour supprimer les en-têtes, etc.

        # Ici, nous ne faisons que retourner le texte complet, mais vous pouvez ajuster
        # cette méthode selon vos besoins spécifiques.
        return texte_complet

  # temps de calculs
    def extraction_time(self):

      start= time.time()
      lignes = self.extract_rows()
      end= time.time()
      execution_time = end - start
      print(f"l'algo a pris {execution_time} secondes")







